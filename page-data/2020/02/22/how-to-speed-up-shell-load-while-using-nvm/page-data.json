{"componentChunkName":"component---src-templates-post-js","path":"/2020/02/22/how-to-speed-up-shell-load-while-using-nvm/","result":{"data":{"markdownRemark":{"html":"<p>If you are developing any application that depends on NodeJS, using <a href=\"https://github.com/nvm-sh/nvm\" target=\"_blank\" rel=\"noopener noreferrer\">NVM (Node Version Manager)</a> is highly recommended.</p>\n<h3>Issue</h3>\n<p>The only downside of NVM is that it significantly slows down shell prompt initialization while using the default settings.</p>\n<p>Here is how it is configured by default for bash:</p>\n<pre><code># Load NVM\nexport NVM_DIR=~/.nvm\n[[ -s \"$NVM_DIR/nvm.sh\" ]] &#x26;&#x26; source \"$NVM_DIR/nvm.sh\"\n</code></pre>\n<p>And here is how bad it performs:</p>\n<pre><code>$ time source ~/.bash_profile\n\nreal 0m0.478s\nuser 0m0.291s\nsys  0m0.198s\n</code></pre>\n<h3>First solution, lazy load NVM</h3>\n<p>There are simple bash scripts that can lazy load NVM during the first invoke of the <code>nvm</code> command. Of course catching <code>nvm</code> is not enough, script should also be checking for <code>npm</code>, <code>node</code>, <code>npx</code>, and any other global package that is installed. Also that very first load will be equally slow to the timings shown above.</p>\n<p>Here is how a minimal bash script would look like for capturing the <code>node</code> command and lazy loading NVM:</p>\n<pre><code>lazy_load_nvm() {\n  unset -f node\n  export NVM_DIR=~/.nvm\n  [[ -s \"$NVM_DIR/nvm.sh\" ]] &#x26;&#x26; source \"$NVM_DIR/nvm.sh\"\n}\n\nnode() {\n  lazy_load_nvm\n  node $@\n}\n</code></pre>\n<p>The <code>node</code> function above can be replicated for capturing the other executables of choice, just remember that they should be included on the unset command as well.</p>\n<h3>Second solution, load NVM in a much faster way</h3>\n<p>NVM while loading up is checking which node version to auto-use based on <code>.nvmrc</code> or a similar configuration file. And this exact check is the one that takes most of the time to complete.<br>\nGood news is that there is a flag for skipping this check.<br>\nHowever without an autoloaded node version, there should still exist a fallback to a preferred version for fast access.</p>\n<p>Putting those two together on the bash init is as simple as:</p>\n<pre><code># Add default node to path\nexport PATH=~/.nvm/versions/node/v12.16.1/bin:$PATH\n\n# Load NVM\nexport NVM_DIR=~/.nvm\n[[ -s \"$NVM_DIR/nvm.sh\" ]] &#x26;&#x26; source \"$NVM_DIR/nvm.sh\" --no-use\n</code></pre>\n<p>Let's measure the startup time:</p>\n<pre><code>$ time source ~/.bash_profile\n\nreal 0m0.051s\nuser 0m0.031s\nsys\t 0m0.018s\n</code></pre>\n<p>Boom, almost half a second faster!</p>\n<p>If a project is using a different node version than the one declared on the bash init, then it's just a matter of remember running <code>nvm use</code> before issuing any other node related commands.<br>\nUpdating the default version via NVM, would also require updating manually the version on bash init.</p>\n<h3>Conclusion</h3>\n<p>I personally prefer the second solution, as I am usually working with the latest LTS node version on active projects. Thus I rarely have to invoke <code>nvm use</code> manually. Time saved overall from spawning shell instances definitely worths it.</p>","frontmatter":{"title":"How to speed up shell load while using NVM","date":"22 Feb 2020"}}},"pageContext":{}},"staticQueryHashes":["2875828811"]}